<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Sum of Sines | Orcenhaze</title>
<meta name="keywords" content="">
<meta name="description" content="C/C&#43;&#43; - custom engine">
<meta name="author" content="">
<link rel="canonical" href="https://orcenhaze.github.io/projects/sum_of_sines/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://orcenhaze.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://orcenhaze.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://orcenhaze.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://orcenhaze.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://orcenhaze.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Sum of Sines" />
<meta property="og:description" content="C/C&#43;&#43; - custom engine" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://orcenhaze.github.io/projects/sum_of_sines/" />
<meta property="og:image" content="https://orcenhaze.github.io/projects/sum_of_sines/sea.png" /><meta property="article:section" content="projects" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://orcenhaze.github.io/projects/sum_of_sines/sea.png" />
<meta name="twitter:title" content="Sum of Sines"/>
<meta name="twitter:description" content="C/C&#43;&#43; - custom engine"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Projects",
      "item": "https://orcenhaze.github.io/projects/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Sum of Sines",
      "item": "https://orcenhaze.github.io/projects/sum_of_sines/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Sum of Sines",
  "name": "Sum of Sines",
  "description": "C/C++ - custom engine",
  "keywords": [
    
  ],
  "articleBody": "Examples Breakdown The Equation These animations were achieved using the following equation:\nfloat h = A * sin(k*p - w*t); A = amplitude; k = spatial_angular_frequency; // (a.k.a. wavenumber) p = position in space; w = temporal_angular_frequency; t = time; This equation is a sinusoidal function; it represents periodic oscillations or waves. We can use the result of this function as a height to some vertex we are drawing in our world.\nIn a 3D world where +X is right, +Y is up, and +Z is towards the viewer, I create an xz-plane with a bunch of vertices. Then in the vertex shader, I calculate the height of each vertex (y-coordinate) based on this equation.\nIt’s more intuitive to parametrize a wave like so:\namplitude: Half-height of wave, i.e., distance from crest/trough to still-water line. wavelength: Length of one wave cycle. speed: How fast the wave moves. From these parameters, we can derive: // Wavenumber / Spatial angular frequency. k = 2 * PI / wavelength; // Temporal angular frequency. w = k * speed; // We can use it directly. A = amplitude; // Time is a value we increase every frame in the CPU by delta_time and we pass it to GPU in a constant buffer. t = time; // Position of the current vertex in some dimension. We can do cool patterns by modifying this value as I'll show later. p = vertex.position.x and/or vertex.position.z; With this, we can calculate the height of each vertex (of the plane) using that equation and we’d get something that resembles a sine wave moving on the surface of the plane.\nThe cool part is that we can combine the result of multiple sinusoidal waves where each wave has different parameters:\nSo, in HLSL, we have something like the following:\nstruct Water_Wave { float amplitude; float spatial_angular_frequency; // TAU / wavelength; float temporal_angular_frequency; // spatial_angular_frequency * speed; }; cbuffer Constants : register(b0) { float time; int wave_count; // ... } // We pass a bunch of random Waves from the CPU. StructuredBuffer\u003cWater_Wave\u003e waves : register(t0); float3 sine(float3 v_pos, Water_Wave wave) { float k = wave.spatial_angular_frequency; float w = wave.temporal_angular_frequency; float p = v_pos.x; // -/+v_pos.x: wave moves left/right... -/+v_pos.z: wave moves forward/backward. float h = wave.amplitude * sin(k * p - w * time); // Displace along +Y axis. return float3(0, h, 0); } PS_Input vs(float3 position : POSITION) { // ... // Position perturbation. float3 offset = 0.0f; for (int wave_index = 0; wave_index \u003c wave_count; wave_index++) { offset += sine(position, waves[wave_index]); } // Final pos = original position + position perturbation. float3 final_pos = position + offset; // final_pos is in local space here, we can transform it now. // ... } Different Wave Patterns Instead of directly using the vertex position in the sine() function, we can achieve different wave patterns by interpreting the vertex position differently:\nDirectional float get_wave_coord(float3 v_pos, Water_Wave wave) { // Project vertex position on desired direction. float result = 0.0f; result = dot(v_pos.xz, wave.direction); return result; } float3 sine(float3 v_pos, Water_Wave wave) { float k = wave.spatial_angular_frequency; float w = wave.temporal_angular_frequency; float p = get_wave_coord(v_pos, wave); float h = wave.amplitude * sin(k * p - w * time); // Displace along +Y axis. return float3(0, h, 0); } Radial { // Distance from origin. result = length(v_pos); } Oscillating Radial { // Oscillating wave along a circular path. result = sin(length(v_pos)); } Spiral { float angle = atan2(v_pos.x, v_pos.z); float radius = length(v_pos); result = sin(radius - angle); } Elliptical { // Elliptical wave with different axis lengths. result = length(v_pos.xz / float2(2.0, 1.0f)); } Latticed { result = sin(v_pos.x * 2.0) + sin(v_pos.z * 2.0); } Calculating Normals Normals are direction vectors that point directly away from a surface. We need normals for light calculations that make our waves look nice.\nThe way we calculate a normal of a surface at some point ‘p’ is by doing a cross product between two other vectors: the tangent and bitangent. The tangent and bitangent are vectors that “just touch” the surface at the point ‘p’. They are perpendicular to one another and doing a cross product between them gives us a third vector that is perpendicular to both (the normal):\nNote: There are infinite tangent and bitangent lines for a given surface, I just have to ensure that whichever ones I choose, it must be always true that normal = cross(tangent, bitangent), noting that I use a right-handed system.\nTo retrieve the tangent and bitangent of a surface at some point, we need to do some calculus, so let’s take a step back:\nImagine a hill that rises and falls as you walk in the x-direction. The height value varies based on ‘x’. The rate of change of height tells us how steeply the surface rises or falls in the x-direction. This is the same thing as saying:\nThe rate of change of ‘y’ with respect to ‘x’ The derivative of ‘y’ with respect to ‘x’ dy/dx The slope of the height of the surface at point ‘p’ in direction ‘x’ The direction of the tangent is along the surface of the hill.\nSo, the tangent at a point where the height is zero is: float3(1, 0, 0)\nOtherwise the tangent will be tilted based on the rate of change of height with respect to the x-direction.\nWe know the function we’re using to calculate the height (assume simple sine wave propagating in x-direction):\nfloat h = A * sin(k*pos.x - w*t); The derivative of that is:\nfloat dh_dx = A * k * cos(k*pos.x - w*t); The tangent is then:\nfloat3 tangent = normalize(float3(1, dh_dx, 0)); Now let’s do the same in 3D:\nWe’re dealing with the xz-plane; the normal of that plane is the y-axis/up-vector. There are infinite possibilities to choose from when it comes to the direction of the tangent and bitangent vectors. But remember, I just have to ensure that N = cross(T, B).\nLet’s choose (T = z-axis) and (B = x-axis).\nNow doing cross(T, B) correctly gives the y-axis (use the right-hand rule to see).\nSo:\nfloat dh_dx = A * k * cos(k*pos.x - w*t); float dh_dz = A * k * cos(k*pos.z - w*t); float3 tangent = normalize(float3(0, dh_dz, 1)); // Along z-axis float3 bitangent = normalize(float3(1, dh_dz, 0)); // Along x-axis float3 normal = cross(tangent, bitangent) = float3(-dh_dx, 1, -dh_dz); We can omit the cross product calculation by directly doing float3 normal = float3(-dh_dx, 1.0, -dh_dz);\nHowever, it’s super important to note that we have multiple waves, so we want to accumulate the “tilt” of the normal from all the waves:\nfloat4 ps(PS_Input input) : SV_TARGET { // ... // Normal perturbation. float3 offset = 0.0f; for (int wave_index = 0; wave_index \u003c wave_count; wave_index++) { offset += sine_normal(input.local_pos, waves[wave_index]); } // Final nor = original normal + normal perturbation. float3 final_nor = float3(0,1,0) + offset; // final_nor is in local space here, we can transform and normalize it now. // ... } Basically, sine_normal() should return only float3(-dh_dx, 0, -dh_dz);\nDifferent wave patterns will have different derivatives.\nDirectional float3 sine_normal(float3 v_pos, Water_Wave wave) { float k = wave.spatial_angular_frequency; float w = wave.temporal_angular_frequency; float A = wave.amplitude; // This is the height rate of change in the wave's propagation direction. float dHeight_dr = A * k * cos(k * get_wave_coord(v_pos, wave) - w * time); // Directional wave pattern. float dHeight_dx = dHeight_dr * wave.direction.x; float dHeight_dz = dHeight_dr * wave.direction.y; return float3(-dHeight_dx, 0.0f, -dHeight_dz); } Radial // Radial waves - derivative with respect to radial distance. float2 grad_r = normalize(v_pos.xz); dHeight_dx = dHeight_dr * grad_r.x; dHeight_dz = dHeight_dr * grad_r.y; Oscillating Radial float radius = length(v_pos); float2 grad_r = normalize(v_pos.xz); dHeight_dx = dHeight_dr * grad_r.x * cos(radius); dHeight_dz = dHeight_dr * grad_r.y * cos(radius); Spiral // Spiral wave - polar coordinates (angle and radius). float radius = length(v_pos); float angle = atan2(v_pos.x, v_pos.z); float2 grad_r = normalize(v_pos.xz); dHeight_dx = dHeight_dr * grad_r.x * cos(radius - angle); dHeight_dz = dHeight_dr * grad_r.y * cos(radius - angle); Elliptical // Elliptical wave - scaled coordinates. float2 scaled_pos = v_pos.xz / float2(2.0, 1.0); float2 grad_scaled = normalize(scaled_pos) / float2(2.0, 1.0); dHeight_dx = dHeight_dr * grad_scaled.x; dHeight_dz = dHeight_dr * grad_scaled.y; Latticed // Lattice wave - derivatives in both x and z directions. dHeight_dx = dHeight_dr * 2.0 * cos(2.0 * v_pos.x); dHeight_dz = dHeight_dr * 2.0 * cos(2.0 * v_pos.z); The main resource I can recommend is Acerola’s awesome videos:\nhttps://www.youtube.com/watch?v=PH9q0HNBjT4\nNote: There’s a small mistake in the video where the spatial angular frequency is shown to be 2 / wavelength when in reality it’s meant to be 2 * PI / wavelength\nWave simulation can be improved with Fractional Brownian Motion (FBM) and Fast Fourier Transforms (FFT), which is what I’m planning to look at next.\nThanks for reading ^^\n",
  "wordCount" : "1473",
  "inLanguage": "en",
  "image":"https://orcenhaze.github.io/projects/sum_of_sines/sea.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://orcenhaze.github.io/projects/sum_of_sines/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Orcenhaze",
    "logo": {
      "@type": "ImageObject",
      "url": "https://orcenhaze.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://orcenhaze.github.io/" accesskey="h" title="Orcenhaze (Alt + H)">
                <img src="https://orcenhaze.github.io/52_logo.jpg" alt="" aria-label="logo"
                    height="40">Orcenhaze</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://orcenhaze.github.io/" title="Home">Home
                </a>
            </li>
            <li>
                <a href="https://orcenhaze.itch.io/" title="My Games">My Games&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://orcenhaze.github.io/blog/" title="Blog">Blog
                </a>
            </li>
            <li>
                <a href="https://orcenhaze.github.io/projects/" title="Projects">Projects
                </a>
            </li>
            <li>
                <a href="https://orcenhaze.github.io/art/" title="Art">Art
                </a>
            </li>
            <li>
                <a href="https://www.youtube.com/@orcenhaze2600/playlists/" title="YouTube">YouTube&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">



<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Sum of Sines
    </h1>
    <div class="post-description">
      C/C&#43;&#43; - custom engine
    </div>
    <div class="post-meta">

</div>
  </header> 
<figure class="entry-cover">
    <img loading="lazy" src="https://orcenhaze.github.io/projects/sum_of_sines/sea.png" alt="">
            
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#examples" aria-label="Examples">Examples</a></li>
                <li>
                    <a href="#breakdown" aria-label="Breakdown">Breakdown</a><ul>
                        
                <li>
                    <a href="#the-equation" aria-label="The Equation">The Equation</a></li>
                <li>
                    <a href="#different-wave-patterns" aria-label="Different Wave Patterns">Different Wave Patterns</a><ul>
                        
                <li>
                    <a href="#directional" aria-label="Directional">Directional</a></li>
                <li>
                    <a href="#radial" aria-label="Radial">Radial</a></li>
                <li>
                    <a href="#oscillating-radial" aria-label="Oscillating Radial">Oscillating Radial</a></li>
                <li>
                    <a href="#spiral" aria-label="Spiral">Spiral</a></li>
                <li>
                    <a href="#elliptical" aria-label="Elliptical">Elliptical</a></li>
                <li>
                    <a href="#latticed" aria-label="Latticed">Latticed</a></li></ul>
                </li>
                <li>
                    <a href="#calculating-normals" aria-label="Calculating Normals">Calculating Normals</a><ul>
                        
                <li>
                    <a href="#directional-1" aria-label="Directional">Directional</a></li>
                <li>
                    <a href="#radial-1" aria-label="Radial">Radial</a></li>
                <li>
                    <a href="#oscillating-radial-1" aria-label="Oscillating Radial">Oscillating Radial</a></li>
                <li>
                    <a href="#spiral-1" aria-label="Spiral">Spiral</a></li>
                <li>
                    <a href="#elliptical-1" aria-label="Elliptical">Elliptical</a></li>
                <li>
                    <a href="#latticed-1" aria-label="Latticed">Latticed</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="examples">Examples<a hidden class="anchor" aria-hidden="true" href="#examples">#</a></h1>
<p>


<video width="100%" height="100%" controls>
    <source src="beauty.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="lattice.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="royal.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="red.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="loli.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="black.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="blue.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="gold.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="green.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="indigo.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="maroon.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="yellow.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="ripple_1.mp4" type="video/mp4">
</video>



<video width="100%" height="100%" controls>
    <source src="sea.mp4" type="video/mp4">
</video></p>
<h1 id="breakdown">Breakdown<a hidden class="anchor" aria-hidden="true" href="#breakdown">#</a></h1>
<h2 id="the-equation">The Equation<a hidden class="anchor" aria-hidden="true" href="#the-equation">#</a></h2>
<p>These animations were achieved using the following equation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>float h = A * sin(k*p - w*t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>A = amplitude;
</span></span><span style="display:flex;"><span>k = spatial_angular_frequency; // (a.k.a. wavenumber)
</span></span><span style="display:flex;"><span>p = position in space;
</span></span><span style="display:flex;"><span>w = temporal_angular_frequency;
</span></span><span style="display:flex;"><span>t = time;
</span></span></code></pre></div><p>This equation is a sinusoidal function; it represents periodic oscillations or waves. We can use the result of this function as a height to some vertex we are drawing in our world.</p>
<p>In a 3D world where +X is right, +Y is up, and +Z is towards the viewer, I create an xz-plane with a bunch of vertices. Then in the vertex shader, I calculate the height of each vertex (y-coordinate) based on this equation.</p>
<p>It&rsquo;s more intuitive to parametrize a wave like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>amplitude:  Half-height of wave, i.e., distance from crest/trough to still-water line.
</span></span><span style="display:flex;"><span>wavelength: Length of one wave cycle.
</span></span><span style="display:flex;"><span>speed:      How fast the wave moves.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>From these parameters, we can derive:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// Wavenumber / Spatial angular frequency.
</span></span><span style="display:flex;"><span>k = 2 * PI / wavelength;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// Temporal angular frequency.
</span></span><span style="display:flex;"><span>w = k * speed;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// We can use it directly.
</span></span><span style="display:flex;"><span>A = amplitude;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// Time is a value we increase every frame in the CPU by delta_time and we pass it to GPU in a constant buffer.
</span></span><span style="display:flex;"><span>t = time;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// Position of the current vertex in some dimension. We can do cool patterns by modifying this value as I&#39;ll show later.
</span></span><span style="display:flex;"><span>p = vertex.position.x and/or vertex.position.z;
</span></span></code></pre></div><p>With this, we can calculate the height of each vertex (of the plane) using that equation and we&rsquo;d get something that resembles a sine wave moving on the surface of the plane.</p>
<p>The cool part is that we can combine the result of multiple sinusoidal waves where each wave has different parameters:</p>
<figure><a href="desmos_1.png" target="_blank">
    <img loading="lazy" src="desmos_1.png"/> </a>
</figure>

<p>So, in HLSL, we have something like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> Water_Wave
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> amplitude;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> spatial_angular_frequency;  <span style="color:#75715e">// TAU / wavelength;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> temporal_angular_frequency; <span style="color:#75715e">// spatial_angular_frequency * speed;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">cbuffer</span> Constants <span style="color:#f92672">:</span> <span style="color:#66d9ef">register</span>(b0)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> time;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> wave_count;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// We pass a bunch of random Waves from the CPU.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">StructuredBuffer</span><span style="color:#f92672">&lt;</span>Water_Wave<span style="color:#f92672">&gt;</span> waves <span style="color:#f92672">:</span> <span style="color:#66d9ef">register</span>(t0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float3</span> sine(<span style="color:#66d9ef">float3</span> v_pos, Water_Wave wave)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> k <span style="color:#f92672">=</span> wave.spatial_angular_frequency;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> w <span style="color:#f92672">=</span> wave.temporal_angular_frequency;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> p <span style="color:#f92672">=</span> v_pos.x; <span style="color:#75715e">// -/+v_pos.x: wave moves left/right... -/+v_pos.z: wave moves forward/backward.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> h <span style="color:#f92672">=</span> wave.amplitude <span style="color:#f92672">*</span> sin(k <span style="color:#f92672">*</span> p <span style="color:#f92672">-</span> w <span style="color:#f92672">*</span> time);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Displace along +Y axis.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">float3</span>(<span style="color:#ae81ff">0</span>, h, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PS_Input vs(<span style="color:#66d9ef">float3</span> position <span style="color:#f92672">:</span> POSITION)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Position perturbation.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float3</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0f</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> wave_index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; wave_index <span style="color:#f92672">&lt;</span> wave_count; wave_index<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">+=</span> sine(position, waves[wave_index]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Final pos = original position + position perturbation. </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float3</span> final_pos <span style="color:#f92672">=</span> position <span style="color:#f92672">+</span> offset;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// final_pos is in local space here, we can transform it now.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="different-wave-patterns">Different Wave Patterns<a hidden class="anchor" aria-hidden="true" href="#different-wave-patterns">#</a></h2>
<p>Instead of directly using the vertex position in the <code>sine()</code> function, we can achieve different wave patterns by interpreting the vertex position differently:</p>
<h3 id="directional">Directional<a hidden class="anchor" aria-hidden="true" href="#directional">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> get_wave_coord(<span style="color:#66d9ef">float3</span> v_pos, Water_Wave wave)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Project vertex position on desired direction.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0f</span>;
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> dot(v_pos.xz, wave.direction);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float3</span> sine(<span style="color:#66d9ef">float3</span> v_pos, Water_Wave wave)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> k <span style="color:#f92672">=</span> wave.spatial_angular_frequency;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> w <span style="color:#f92672">=</span> wave.temporal_angular_frequency;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> p <span style="color:#f92672">=</span> get_wave_coord(v_pos, wave);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> h <span style="color:#f92672">=</span> wave.amplitude <span style="color:#f92672">*</span> sin(k <span style="color:#f92672">*</span> p <span style="color:#f92672">-</span> w <span style="color:#f92672">*</span> time);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Displace along +Y axis.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">float3</span>(<span style="color:#ae81ff">0</span>, h, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>


<video width="100%" height="100%" controls>
    <source src="pattern_directional.mp4" type="video/mp4">
</video>
<h3 id="radial">Radial<a hidden class="anchor" aria-hidden="true" href="#radial">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Distance from origin.</span>
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> length(v_pos);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>


<video width="100%" height="100%" controls>
    <source src="pattern_radial.mp4" type="video/mp4">
</video>
<h3 id="oscillating-radial">Oscillating Radial<a hidden class="anchor" aria-hidden="true" href="#oscillating-radial">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Oscillating wave along a circular path.</span>
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> sin(length(v_pos));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>


<video width="100%" height="100%" controls>
    <source src="pattern_osc_radial.mp4" type="video/mp4">
</video>
<h3 id="spiral">Spiral<a hidden class="anchor" aria-hidden="true" href="#spiral">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> angle  <span style="color:#f92672">=</span> atan2(v_pos.x, v_pos.z);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> radius <span style="color:#f92672">=</span> length(v_pos);
</span></span><span style="display:flex;"><span>    result       <span style="color:#f92672">=</span> sin(radius <span style="color:#f92672">-</span> angle);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>


<video width="100%" height="100%" controls>
    <source src="pattern_spiral.mp4" type="video/mp4">
</video>
<h3 id="elliptical">Elliptical<a hidden class="anchor" aria-hidden="true" href="#elliptical">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Elliptical wave with different axis lengths.</span>
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> length(v_pos.xz <span style="color:#f92672">/</span> <span style="color:#66d9ef">float2</span>(<span style="color:#ae81ff">2.0</span>, <span style="color:#ae81ff">1.0f</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>


<video width="100%" height="100%" controls>
    <source src="pattern_elliptical.mp4" type="video/mp4">
</video>
<h3 id="latticed">Latticed<a hidden class="anchor" aria-hidden="true" href="#latticed">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> sin(v_pos.x <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span>) <span style="color:#f92672">+</span> sin(v_pos.z <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>


<video width="100%" height="100%" controls>
    <source src="pattern_lattice.mp4" type="video/mp4">
</video>
<h2 id="calculating-normals">Calculating Normals<a hidden class="anchor" aria-hidden="true" href="#calculating-normals">#</a></h2>
<p>Normals are direction vectors that point directly away from a surface. We need normals for light calculations that make our waves look nice.</p>
<p>The way we calculate a normal of a surface at some point &lsquo;p&rsquo; is by doing a cross product between two other vectors: the tangent and bitangent. The tangent and bitangent are vectors that &ldquo;just touch&rdquo; the surface at the point &lsquo;p&rsquo;. They are perpendicular to one another and doing a cross product between them gives us a third vector that is perpendicular to both (the normal):</p>
<figure><a href="TBN.png" target="_blank">
    <img loading="lazy" src="TBN.png"/> </a>
</figure>

<p><strong>Note:</strong> There are infinite tangent and bitangent lines for a given surface, I just have to ensure that whichever ones I choose, it must be always true that <code>normal = cross(tangent, bitangent)</code>, noting that I use a right-handed system.</p>
<p>To retrieve the tangent and bitangent of a surface at some point, we need to do some calculus, so let&rsquo;s take a step back:<br>
Imagine a hill that rises and falls as you walk in the x-direction. The height value varies based on &lsquo;x&rsquo;. The rate of change of height tells us how steeply the surface rises or falls in the x-direction. This is the same thing as saying:</p>
<ul>
<li>The rate of change of &lsquo;y&rsquo; with respect to &lsquo;x&rsquo;</li>
<li>The derivative of &lsquo;y&rsquo; with respect to &lsquo;x&rsquo;</li>
<li>dy/dx</li>
<li>The slope of the height of the surface at point &lsquo;p&rsquo; in direction &lsquo;x&rsquo;</li>
</ul>
<p>The direction of the tangent is along the surface of the hill.<br>
So, the tangent at a point where the height is zero is: <code>float3(1, 0, 0)</code><br>
Otherwise the tangent will be tilted based on the rate of change of height with respect to the
x-direction.</p>
<p>We know the function we&rsquo;re using to calculate the height (assume simple sine wave propagating in x-direction):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> h <span style="color:#f92672">=</span> A <span style="color:#f92672">*</span> sin(k<span style="color:#f92672">*</span>pos.x <span style="color:#f92672">-</span> w<span style="color:#f92672">*</span>t);
</span></span></code></pre></div><p>The derivative of that is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> dh_dx <span style="color:#f92672">=</span> A <span style="color:#f92672">*</span> k <span style="color:#f92672">*</span> cos(k<span style="color:#f92672">*</span>pos.x <span style="color:#f92672">-</span> w<span style="color:#f92672">*</span>t);
</span></span></code></pre></div><p>The tangent is then:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span><span style="color:#66d9ef">float3</span> tangent <span style="color:#f92672">=</span> normalize(<span style="color:#66d9ef">float3</span>(<span style="color:#ae81ff">1</span>, dh_dx, <span style="color:#ae81ff">0</span>));
</span></span></code></pre></div><hr>
<p>Now let&rsquo;s do the same in 3D:</p>
<p>We&rsquo;re dealing with the xz-plane; the normal of that plane is the y-axis/up-vector. There are infinite possibilities to choose from when it comes to the direction of the tangent and bitangent vectors. But remember, I just have to ensure that <code>N = cross(T, B)</code>.</p>
<p>Let&rsquo;s choose (T = z-axis) and (B = x-axis).<br>
Now doing <code>cross(T, B)</code> correctly gives the y-axis (use the right-hand rule to see).</p>
<p>So:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> dh_dx <span style="color:#f92672">=</span> A <span style="color:#f92672">*</span> k <span style="color:#f92672">*</span> cos(k<span style="color:#f92672">*</span>pos.x <span style="color:#f92672">-</span> w<span style="color:#f92672">*</span>t);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> dh_dz <span style="color:#f92672">=</span> A <span style="color:#f92672">*</span> k <span style="color:#f92672">*</span> cos(k<span style="color:#f92672">*</span>pos.z <span style="color:#f92672">-</span> w<span style="color:#f92672">*</span>t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float3</span> tangent   <span style="color:#f92672">=</span> normalize(<span style="color:#66d9ef">float3</span>(<span style="color:#ae81ff">0</span>, dh_dz, <span style="color:#ae81ff">1</span>)); <span style="color:#75715e">// Along z-axis</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float3</span> bitangent <span style="color:#f92672">=</span> normalize(<span style="color:#66d9ef">float3</span>(<span style="color:#ae81ff">1</span>, dh_dz, <span style="color:#ae81ff">0</span>)); <span style="color:#75715e">// Along x-axis</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float3</span> normal <span style="color:#f92672">=</span> cross(tangent, bitangent) <span style="color:#f92672">=</span> <span style="color:#66d9ef">float3</span>(<span style="color:#f92672">-</span>dh_dx, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span>dh_dz);
</span></span></code></pre></div><p>We can omit the cross product calculation by directly doing <code>float3 normal = float3(-dh_dx, 1.0, -dh_dz);</code><br>
However, it&rsquo;s super <strong>important to note</strong> that we have multiple waves, so we want to accumulate the &ldquo;tilt&rdquo; of the normal from all the waves:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span><span style="color:#66d9ef">float4</span> ps(PS_Input input) <span style="color:#f92672">:</span> SV_TARGET
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Normal perturbation.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float3</span> offset  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0f</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> wave_index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; wave_index <span style="color:#f92672">&lt;</span> wave_count; wave_index<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">+=</span> sine_normal(input.local_pos, waves[wave_index]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Final nor = original normal + normal perturbation.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float3</span> final_nor <span style="color:#f92672">=</span> <span style="color:#66d9ef">float3</span>(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> offset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// final_nor is in local space here, we can transform and normalize it now.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Basically, <code>sine_normal()</code> should return only <code>float3(-dh_dx, 0, -dh_dz);</code></p>
<hr>
<p>Different wave patterns will have different derivatives.</p>
<h3 id="directional-1">Directional<a hidden class="anchor" aria-hidden="true" href="#directional-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span><span style="color:#66d9ef">float3</span> sine_normal(<span style="color:#66d9ef">float3</span> v_pos, Water_Wave wave)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> k  <span style="color:#f92672">=</span> wave.spatial_angular_frequency;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> w  <span style="color:#f92672">=</span> wave.temporal_angular_frequency;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> A  <span style="color:#f92672">=</span> wave.amplitude;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This is the height rate of change in the wave&#39;s propagation direction.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> dHeight_dr <span style="color:#f92672">=</span> A <span style="color:#f92672">*</span> k <span style="color:#f92672">*</span> cos(k <span style="color:#f92672">*</span> get_wave_coord(v_pos, wave) <span style="color:#f92672">-</span> w <span style="color:#f92672">*</span> time);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Directional wave pattern.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> dHeight_dx <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> wave.direction.x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> dHeight_dz <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> wave.direction.y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">float3</span>(<span style="color:#f92672">-</span>dHeight_dx, <span style="color:#ae81ff">0.0f</span>, <span style="color:#f92672">-</span>dHeight_dz);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="radial-1">Radial<a hidden class="anchor" aria-hidden="true" href="#radial-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span>    <span style="color:#75715e">// Radial waves - derivative with respect to radial distance.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> grad_r <span style="color:#f92672">=</span> normalize(v_pos.xz);
</span></span><span style="display:flex;"><span>    dHeight_dx    <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> grad_r.x;
</span></span><span style="display:flex;"><span>    dHeight_dz    <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> grad_r.y;
</span></span></code></pre></div><h3 id="oscillating-radial-1">Oscillating Radial<a hidden class="anchor" aria-hidden="true" href="#oscillating-radial-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> radius  <span style="color:#f92672">=</span> length(v_pos);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> grad_r <span style="color:#f92672">=</span> normalize(v_pos.xz);
</span></span><span style="display:flex;"><span>    dHeight_dx    <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> grad_r.x <span style="color:#f92672">*</span> cos(radius);
</span></span><span style="display:flex;"><span>    dHeight_dz    <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> grad_r.y <span style="color:#f92672">*</span> cos(radius);
</span></span></code></pre></div><h3 id="spiral-1">Spiral<a hidden class="anchor" aria-hidden="true" href="#spiral-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span>    <span style="color:#75715e">// Spiral wave - polar coordinates (angle and radius).</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> radius  <span style="color:#f92672">=</span> length(v_pos);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> angle   <span style="color:#f92672">=</span> atan2(v_pos.x, v_pos.z);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> grad_r <span style="color:#f92672">=</span> normalize(v_pos.xz);
</span></span><span style="display:flex;"><span>    dHeight_dx    <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> grad_r.x <span style="color:#f92672">*</span> cos(radius <span style="color:#f92672">-</span> angle);
</span></span><span style="display:flex;"><span>    dHeight_dz    <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> grad_r.y <span style="color:#f92672">*</span> cos(radius <span style="color:#f92672">-</span> angle);
</span></span></code></pre></div><h3 id="elliptical-1">Elliptical<a hidden class="anchor" aria-hidden="true" href="#elliptical-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span>    <span style="color:#75715e">// Elliptical wave - scaled coordinates.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> scaled_pos  <span style="color:#f92672">=</span> v_pos.xz <span style="color:#f92672">/</span> <span style="color:#66d9ef">float2</span>(<span style="color:#ae81ff">2.0</span>, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> grad_scaled <span style="color:#f92672">=</span> normalize(scaled_pos) <span style="color:#f92672">/</span> <span style="color:#66d9ef">float2</span>(<span style="color:#ae81ff">2.0</span>, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    dHeight_dx         <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> grad_scaled.x;
</span></span><span style="display:flex;"><span>    dHeight_dz         <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> grad_scaled.y;
</span></span></code></pre></div><h3 id="latticed-1">Latticed<a hidden class="anchor" aria-hidden="true" href="#latticed-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-HLSL" data-lang="HLSL"><span style="display:flex;"><span>    <span style="color:#75715e">// Lattice wave - derivatives in both x and z directions.</span>
</span></span><span style="display:flex;"><span>    dHeight_dx <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> cos(<span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> v_pos.x);
</span></span><span style="display:flex;"><span>    dHeight_dz <span style="color:#f92672">=</span> dHeight_dr <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> cos(<span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> v_pos.z);
</span></span></code></pre></div><hr>
<p>The main resource I can recommend is Acerola&rsquo;s awesome videos:<br>
<a href="https://www.youtube.com/watch?v=PH9q0HNBjT4">https://www.youtube.com/watch?v=PH9q0HNBjT4</a></p>
<p><strong>Note</strong>: There&rsquo;s a small mistake in the video where the spatial angular frequency is shown to be <code>2 / wavelength</code> when in reality it&rsquo;s meant to be <code>2 * PI / wavelength</code></p>
<p>Wave simulation can be improved with Fractional Brownian Motion (FBM) and Fast Fourier Transforms (FFT), which is what I&rsquo;m planning to look at next.</p>
<p>Thanks for reading ^^</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://orcenhaze.github.io/projects/hard_lock_target/">
    <span class="title">Next »</span>
    <br>
    <span>Hard Lock Target</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    <div class="contact">
    Contact:
    <a href="mailto: orcenhaze@gmail.com">orcenhaze@gmail.com</a>
</div>
<footer class="footer">
    <span>&copy; 2025 <a href="https://orcenhaze.github.io/">Orcenhaze</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
